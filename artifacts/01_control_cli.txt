// File: src/lib.rs (lines 1-75)
```rust
//! **roughup** - Super-fast Rust CLI for extracting/packaging source code for LLM workflows
//!
//! Smart gitignore-aware processing with parallel execution and tree-sitter symbol extraction.
//! Performance-first design with memory-mapped I/O and AST caching.

/// Command-line interface with clap integration
pub mod cli;

/// Shell completion generation
pub mod completion;

/// Core processing pipeline - High-performance extraction and analysis (2,847 lines total)
pub mod core {
    /// Line-range extraction with gitignore awareness and memory mapping
    pub mod extract;
    pub use extract::run as extract_run;

    /// Tree-sitter symbol extraction pipeline (Rust+Python locked, 572 lines)
    pub mod symbols;
    pub use symbols::{Symbol, SymbolKind, Visibility, run as symbols_run};

    /// Directory tree visualization with depth control and parallel processing
    pub mod tree;
    pub use tree::run as tree_run;

    /// Token-aware content chunking for LLM workflows with tiktoken integration
    pub mod chunk;
    pub use chunk::run as chunk_run;
}

/// Language processing - AST parsing and symbol extraction with moka caching
pub mod parsers {
    /// Rust symbol extraction with tree-sitter (qualified names, visibility)
    pub mod rust_parser;
    pub use rust_parser::RustExtractor;

    /// Python symbol extraction with tree-sitter (classes, functions, methods)
    pub mod python_parser;
    pub use python_parser::PythonExtractor;

    // Re-export common extractor interface
    pub use crate::core::symbols::{SymbolExtractor, get_extractor};
}

/// Infrastructure - Configuration, I/O, and utilities (lean architecture)
pub mod infra {
    /// Configuration management with TOML support and feature flags
    pub mod config;
    pub use config::{Config, init as config_init, load_config};

    /// Memory-mapped file I/O for large files (>1MB threshold)
    pub mod io;
    pub use io::{FileContent, read_file_smart};

    /// CRLF/LF-robust line indexing for O(1) lineâ†’byte mapping
    pub mod line_index;
    pub use line_index::NewlineIndex;

    /// Gitignore-aware directory walking with rayon parallelism
    pub mod walk;
    pub use walk::FileWalker;

    /// Utility functions and helpers for common operations
    pub mod utils;
    pub use utils::*;
}

// Strategic re-exports for clean CLI interface
pub use cli::{Cli, Commands};
pub use core::{extract, symbols_run, tree_run, chunk_run};
pub use infra::{Config, FileWalker, load_config};
pub use parsers::{PythonExtractor, RustExtractor, SymbolExtractor};

// Core types for external consumers
pub use core::symbols::{Symbol, SymbolKind, Visibility};
```

// File: src/main.rs (lines 1-16)
```rust
use anyhow::Result;
use clap::Parser;
use roughup::cli::{Cli, Commands};

fn main() -> Result<()> {
    let cli = Cli::parse();

    match cli.command {
        Commands::Extract(args) => roughup::core::extract_run(args, cli.dry_run),
        Commands::Tree(args) => roughup::tree_run(args),
        Commands::Symbols(args) => roughup::symbols_run(args),
        Commands::Chunk(args) => roughup::chunk_run(args),
        Commands::Init(args) => roughup::infra::config::init(args),
        Commands::Completions(args) => roughup::completion::run(args),
    }
}
```

// File: src/cli.rs (lines 1-171)
```rust
use clap::{Parser, Subcommand, ValueEnum};
use std::path::PathBuf;

#[derive(Parser)]
#[command(name = "roughup")]
#[command(
    about = "A super-fast, lightweight CLI for extracting and packaging source code for LLM workflows"
)]
#[command(version, long_about = None)]
pub struct Cli {
    #[command(subcommand)]
    pub command: Commands,

    /// Disable colored output
    #[arg(long, global = true)]
    pub no_color: bool,

    /// Suppress progress bars and non-essential output
    #[arg(long, global = true)]
    pub quiet: bool,

    /// Show what would be done without executing
    #[arg(long, global = true)]
    pub dry_run: bool,
}

#[derive(Subcommand)]
pub enum Commands {
    /// Extract specific line ranges from files
    Extract(ExtractArgs),

    /// Display project tree structure
    Tree(TreeArgs),

    /// Extract symbol information from source files
    Symbols(SymbolsArgs),

    /// Split extracted content into token-sized chunks
    Chunk(ChunkArgs),

    /// Initialize a roughup.toml config file
    Init(InitArgs),

    /// Generate shell completions
    Completions(CompletionsArgs),
}

#[derive(Parser)]
pub struct ExtractArgs {
    /// Files and line ranges (format: file.rs:10-20,25-30)
    pub targets: Vec<String>,

    /// Output file path
    #[arg(short, long, default_value = "extracted_source.txt")]
    pub output: PathBuf,

    /// Annotate each extraction with file and line info
    #[arg(long)]
    pub annotate: bool,

    /// Wrap extractions in fenced code blocks
    #[arg(long)]
    pub fence: bool,

    /// Copy result to clipboard
    #[arg(long)]
    pub clipboard: bool,

    /// Show what would be done without executing
    #[arg(long)]
    pub dry_run: bool,
}

#[derive(Parser)]
pub struct TreeArgs {
    /// Root directory to scan
    #[arg(default_value = ".")]
    pub path: PathBuf,

    /// Additional glob patterns to ignore
    #[arg(short, long)]
    pub ignore: Vec<String>,

    /// Maximum depth to traverse
    #[arg(short, long)]
    pub depth: Option<usize>,

    /// Show what would be done without executing
    #[arg(long)]
    pub dry_run: bool,
}

#[derive(Debug, Parser)]
pub struct SymbolsArgs {
    /// Root directory to scan
    #[arg(default_value = ".")]
    pub path: PathBuf,

    /// Languages to include (rust, python, javascript, typescript, go, cpp)
    #[arg(short, long)]
    pub languages: Vec<String>,

    /// Output file path
    #[arg(short, long, default_value = "symbols.jsonl")]
    pub output: PathBuf,

    /// Include private symbols
    #[arg(long)]
    pub include_private: bool,
}

#[derive(Parser)]
pub struct ChunkArgs {
    /// Input file to chunk
    pub input: PathBuf,

    /// Maximum tokens per chunk
    #[arg(long, default_value = "4000")]
    pub max_tokens: usize,

    /// GPT model (gpt-4, gpt-4o, gpt-3.5-turbo) or encoding (o200k_base, cl100k_base)
    #[arg(short, long, default_value = "gpt-4o")]
    pub model: String,

    /// Output directory for chunks
    #[arg(short, long, default_value = "chunks")]
    pub output_dir: PathBuf,

    /// Prefer symbol boundaries when chunking (default: true)
    #[arg(long, default_value = "true")]
    pub by_symbols: bool,

    /// Token overlap between chunks
    #[arg(long, default_value = "128")]
    pub overlap: usize,
}

#[derive(Parser)]
pub struct InitArgs {
    /// Directory to initialize config in
    #[arg(default_value = ".")]
    pub path: PathBuf,

    /// Overwrite existing config file
    #[arg(long)]
    pub force: bool,
}

#[derive(Debug, Clone, ValueEnum)]
pub enum Shell {
    Bash,
    Zsh,
    Fish,
    PowerShell,
    Elvish,
}

#[derive(Parser)]
pub struct CompletionsArgs {
    /// Target shell
    #[arg(value_enum)]
    pub shell: Shell,

    /// Output directory; if omitted and --stdout not set, prints error
    #[arg(long)]
    pub out_dir: Option<PathBuf>,

    /// Print completion script to stdout instead of a file
    #[arg(long)]
    pub stdout: bool,
}
```

// File: src/completion.rs (lines 1-42)
```rust
//! Shell completion generation using clap_complete.

use anyhow::{Context, Result};
use clap::{Command, CommandFactory};
use clap_complete::{generate, generate_to, Shell as CompletionShell};
use std::{fs, io};

use crate::cli::{Cli, CompletionsArgs, Shell};

impl From<Shell> for CompletionShell {
    fn from(shell: Shell) -> Self {
        match shell {
            Shell::Bash => CompletionShell::Bash,
            Shell::Zsh => CompletionShell::Zsh,
            Shell::Fish => CompletionShell::Fish,
            Shell::PowerShell => CompletionShell::PowerShell,
            Shell::Elvish => CompletionShell::Elvish,
        }
    }
}

pub fn run(args: CompletionsArgs) -> Result<()> {
    let mut cmd: Command = Cli::command();
    let shell: CompletionShell = args.shell.into();

    if args.stdout {
        // Generate to stdout
        generate(shell, &mut cmd, "roughup", &mut io::stdout());
        return Ok(());
    }

    let dir = args
        .out_dir
        .ok_or_else(|| anyhow::anyhow!("--out-dir is required unless --stdout is set"))?;
    
    fs::create_dir_all(&dir).context("create --out-dir")?;
    let path = generate_to(shell, &mut cmd, "roughup", &dir)
        .context("generate completion file")?;
    
    eprintln!("Wrote completion to {}", path.display());
    Ok(())
}
```
