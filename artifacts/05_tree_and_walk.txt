// File: src/core/tree.rs (lines 1-293)
```rust
//! Filepath: src/core/tree.rs
//! Tree view that appends per-file total line counts as `name:lines`
//! e.g., `main.rs:100`. Directories are displayed as before.
//!
//! Performance notes:
//! - Counts lines by scanning bytes for '\n' (CRLF-safe).
//! - Memory-mapped for files > 1MB (configurable here).
//! - Uses BTreeMap for deterministic ordering.

use anyhow::{Context, Result};
use owo_colors::OwoColorize;
use ptree::TreeBuilder;
use std::collections::BTreeMap;
use std::fs;
use std::path::{Path, PathBuf};

use crate::cli::TreeArgs;
use crate::infra::config::load_config;
use crate::infra::walk::FileWalker;

const MMAP_THRESHOLD_BYTES: u64 = 1_048_576; // 1 MiB

pub fn run(args: TreeArgs) -> Result<()> {
    let config = load_config().unwrap_or_default();

    // Combine config ignore patterns with CLI args
    let mut ignore_patterns = config.ignore_patterns.clone();
    ignore_patterns.extend(args.ignore);

    let walker = FileWalker::new(&ignore_patterns)?;

    if args.dry_run {
        println!("{}", "DRY RUN: Would scan:".yellow());
        println!("  Root: {}", args.path.display());
        println!("  Max depth: {:?}", args.depth);
        println!("  Ignore patterns: {:?}", ignore_patterns);
        return Ok(());
    }

    // Build file tree with per-file line counts
    let tree = build_tree_with_counts(&args.path, &walker, args.depth)?;

    // Print tree
    print_tree(&tree)?;

    Ok(())
}

#[derive(Debug)]
struct TreeNode {
    name: String,

    #[expect(unused, reason = "TODO: MARKED FOR USE")]
    path: PathBuf,
    is_dir: bool,
    /// For files, total line count; None for directories.
    line_count: Option<usize>,
    children: BTreeMap<String, TreeNode>,
}

impl TreeNode {
    fn new(name: String, path: PathBuf, is_dir: bool) -> Self {
        Self {
            name,
            path,
            is_dir,
            line_count: None,
            children: BTreeMap::new(),
        }
    }

    /// Insert a path into the tree. If `file_lines` is Some(_),
    /// it is applied to the leaf file node.
    fn insert_path(
        &mut self,
        full_path: &Path,
        relative_path: &Path,
        max_depth: Option<usize>,
        current_depth: usize,
        file_lines: Option<usize>,
    ) {
        if let Some(max_depth) = max_depth
            && current_depth >= max_depth
        {
            return;
        }
        if relative_path.components().count() == 0 {
            return;
        }

        let mut components = relative_path.components();
        let first_component = components.next().unwrap();
        let remaining: PathBuf = components.collect();

        let component_name = first_component.as_os_str().to_string_lossy().to_string();
        let component_path = full_path
            .parent()
            .unwrap_or(full_path)
            .join(&component_name);
        let is_dir = component_path.is_dir();

        let entry = self
            .children
            .entry(component_name.clone())
            .or_insert_with(|| {
                TreeNode::new(component_name.clone(), component_path.clone(), is_dir)
            });

        if remaining.as_os_str().is_empty() {
            // Leaf reached. If it's a file and we were given a count, set it.
            if !entry.is_dir
                && let Some(n) = file_lines
            {
                entry.line_count = Some(n);
            }
        } else {
            entry.insert_path(
                &component_path,
                &remaining,
                max_depth,
                current_depth + 1,
                file_lines,
            );
        }
    }
}

/// Build the tree and attach line counts to file leaf nodes.
fn build_tree_with_counts(
    root: &Path,
    walker: &FileWalker,
    max_depth: Option<usize>,
) -> Result<TreeNode> {
    let mut tree = TreeNode::new(
        root.file_name()
            .unwrap_or(root.as_os_str())
            .to_string_lossy()
            .to_string(),
        root.to_path_buf(),
        true,
    );

    // Walk all files once, compute counts, and insert.
    for file_path in walker.walk_files(root) {
        // Compute total lines for this file quickly.
        let lines = count_lines_fast(&file_path)
            .with_context(|| format!("counting lines for {}", file_path.display()))?;

        if let Ok(relative_path) = file_path.strip_prefix(root) {
            tree.insert_path(&file_path, relative_path, max_depth, 0, Some(lines));
        }

        // Also insert parent directories to ensure they exist in the tree.
        let mut current = file_path.parent();
        while let Some(parent) = current {
            if parent == root {
                break;
            }
            if let Ok(relative_path) = parent.strip_prefix(root) {
                tree.insert_path(parent, relative_path, max_depth, 0, None);
            }
            current = parent.parent();
        }
    }

    Ok(tree)
}

/// Print the tree with formatted labels. Files show `name:lines`.
fn print_tree(tree: &TreeNode) -> Result<()> {
    let mut builder = TreeBuilder::new(format_node_label(tree));

    add_children_to_builder(&mut builder, &tree.children);

    let tree = builder.build();
    ptree::print_tree(&tree)?;

    Ok(())
}

fn add_children_to_builder(builder: &mut TreeBuilder, children: &BTreeMap<String, TreeNode>) {
    for child in children.values() {
        if child.children.is_empty() {
            builder.add_empty_child(format_node_label(child));
        } else {
            builder.begin_child(format_node_label(child));
            add_children_to_builder(builder, &child.children);
            builder.end_child();
        }
    }
}

/// Format node label with colors and, for files, appended `:lines`.
fn format_node_label(node: &TreeNode) -> String {
    if node.is_dir {
        format!("{}/", node.name.blue())
    } else {
        let colored = color_by_ext(&node.name);
        match node.line_count {
            Some(n) => format!("{}:{}", colored, n),
            None => colored,
        }
    }
}

fn color_by_ext(name: &str) -> String {
    if let Some(ext) = std::path::Path::new(name)
        .extension()
        .and_then(|e| e.to_str())
    {
        match ext {
            "rs" => name.yellow().to_string(),
            "py" => name.green().to_string(),
            "js" | "jsx" | "ts" | "tsx" => name.cyan().to_string(),
            "go" => name.magenta().to_string(),
            "c" | "cpp" | "cc" | "cxx" | "h" | "hpp" => name.red().to_string(),
            "md" | "txt" | "readme" => name.white().to_string(),
            "toml" | "yaml" | "yml" | "json" => name.bright_blue().to_string(),
            _ => name.to_string(),
        }
    } else {
        name.to_string()
    }
}

/// Fast, CRLF-safe total line counting.
/// Counts '\n' bytes and adds one if the file is non-empty and doesn't end with '\n'.
fn count_lines_fast(path: &Path) -> Result<usize> {
    use memchr::memchr_iter;
    use memmap2::Mmap;
    use std::fs::File;
    use std::io::Read;

    let meta = fs::metadata(path)?;
    if !meta.is_file() {
        return Ok(0);
    }
    let len = meta.len();
    if len == 0 {
        return Ok(0);
    }

    if len >= MMAP_THRESHOLD_BYTES {
        // Memory-map large files
        let file = File::open(path)?;
        // SAFETY: read-only map of an existing regular file
        let mmap = unsafe { Mmap::map(&file)? };
        let bytes = &mmap[..];

        let nl = memchr_iter(b'\n', bytes).count();
        // If the file doesn't end with '\n', last line has no newline terminator
        Ok(if bytes.ends_with(b"\n") { nl } else { nl + 1 })
    } else {
        // Small files: read into memory
        let mut buf = Vec::with_capacity(len as usize);
        File::open(path)?.read_to_end(&mut buf)?;
        let nl = memchr_iter(b'\n', &buf).count();
        Ok(if buf.ends_with(b"\n") { nl } else { nl + 1 })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn test_tree_building_and_counts() -> Result<()> {
        let tmp = TempDir::new()?;
        let root = tmp.path();

        // dirs
        fs::create_dir_all(root.join("src"))?;

        // files
        fs::write(root.join("src/main.rs"), b"fn main() {}\n")?; // 1 line (ends with \n)
        fs::write(root.join("README.md"), b"# Test\nSecond line")?; // 2 lines (no trailing \n)

        let walker = FileWalker::new(&[])?;
        let tree = build_tree_with_counts(root, &walker, None)?;

        // Ensure structure
        let src = tree.children.get("src").expect("src dir present");
        let main = src.children.get("main.rs").expect("main.rs present");
        assert_eq!(main.line_count, Some(1));

        let readme = tree.children.get("README.md").expect("README.md present");
        assert_eq!(readme.line_count, Some(2));

        Ok(())
    }
}
```

// File: src/infra/walk.rs (lines 1-140)
```rust
//! Filepath: src/infra/walk.rs

use anyhow::Result;
use globset::{Glob, GlobSet, GlobSetBuilder};
use ignore::{DirEntry, WalkBuilder};
use std::path::{Path, PathBuf};

/// Gitignore-aware walker with optional extra ignore globs.
/// Extra globs are applied in two places:
///   1) Early: prune directories during traversal (filter_entry).
///   2) Late: filter out files that still slipped through.
pub struct FileWalker {
    /// Compiled set of additional ignore patterns
    ignore_patterns: GlobSet,
}

impl FileWalker {
    /// Build a walker with additional ignore patterns (e.g., "target/**",
    /// "node_modules/**", "**/*.min.js"). These are matched on full paths.
    pub fn new(additional_ignores: &[String]) -> Result<Self> {
        // Create a builder for the glob set
        let mut builder = GlobSetBuilder::new();

        // Add all caller-provided patterns
        for pattern in additional_ignores {
            // Compile each glob; return early on invalid patterns
            let glob = Glob::new(pattern)?;
            builder.add(glob);
        }

        // Build the compiled set (empty if no patterns provided)
        let ignore_patterns = builder.build()?;

        // Return the configured walker
        Ok(Self { ignore_patterns })
    }

    /// Traverse files under `root`, respecting .gitignore and extra globs.
    /// Returns a sorted list of file paths for determinism.
    pub fn walk_files<P: AsRef<Path>>(&self, root: P) -> Vec<PathBuf> {
        let root_path = root.as_ref();
        // Create a builder so we can attach a directory-pruning predicate
        let mut builder = WalkBuilder::new(root.as_ref());

        // Include hidden files; rely on .gitignore for policy
        builder.hidden(false);

        // Respect all gitignore sources (local, global, excludes)
        builder.git_ignore(true);
        builder.git_exclude(true);
        builder.git_global(true);

        // Prune directories that match additional ignore patterns early.
        // This prevents descending into large ignored trees (e.g., target/, node_modules/).
        //
        // Note: we only prune directories here; file-level ignores are handled later.
        let extra = self.ignore_patterns.clone();
        builder.filter_entry(move |ent: &DirEntry| {
            // If we cannot determine the type, keep it (be conservative)
            let is_dir = ent.file_type().map(|ft| ft.is_dir()).unwrap_or(false);

            // If this is a directory and it matches an extra ignore, prune it now
            if is_dir && extra.is_match(ent.path()) {
                return false;
            }

            // Otherwise keep traversing
            true
        });

        // Build the iterator
        let walker = builder.build();

        // Collect only files, excluding those matched by extra globs
        let mut out: Vec<PathBuf> = walker
            // Drop entries with IO errors; production code could collect them
            .filter_map(|res| res.ok())
            // Keep only regular files
            .filter(|entry| entry.file_type().is_some_and(|ft| ft.is_file()))
            // Convert to owned path
            .map(|entry| entry.into_path())
            // Apply file-level extra ignore filtering using relative paths
            .filter(|path| {
                let rel_path = path.strip_prefix(root_path).unwrap_or(path);
                !self.ignore_patterns.is_match(rel_path)
            })
            // Collect into a vector
            .collect();

        // Ensure deterministic output order (useful for tests and stable CLI)
        out.sort();

        // Return file list
        out
    }

    /// Traverse and then apply a caller-provided filter predicate.
    /// This runs after git/extra ignore filtering.
    #[allow(dead_code)]
    pub fn walk_with_filter<P, F>(&self, root: P, filter: F) -> Vec<PathBuf>
    where
        P: AsRef<Path>,
        F: Fn(&Path) -> bool,
    {
        // Run the main traversal
        let files = self.walk_files(root);

        // Apply the caller's predicate
        files.into_iter().filter(|p| filter(p)).collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    /// Create a file with parent dirs as needed
    fn write_file(root: &Path, rel: &str, contents: &str) -> Result<()> {
        // Build absolute path
        let path = root.join(rel);

        // Ensure parent directory exists
        if let Some(parent) = path.parent() {
            std::fs::create_dir_all(parent)?;
        }

        // Write file contents
        fs::write(path, contents)?;

        // Done
        Ok(())
    }

    #[test]
    fn test_file_walking_simple() -> Result<()> {
        // Create an isolated temporary directory
        let temp_dir = TempDir::new()?;
        let root = temp_dir.path();
```

// File: src/infra/walk.rs (lines 141-265)
```rust

        // Create two simple files
        write_file(root, "test.rs", "fn main() {}")?;
        write_file(root, "README.md", "# Test")?;

        // Build a walker with no extra ignores
        let walker = FileWalker::new(&[])?;

        // Walk files
        let files = walker.walk_files(root);

        // We expect exactly these two files
        assert_eq!(files.len(), 2);
        assert!(files.iter().any(|p| p.file_name().unwrap() == "README.md"));
        assert!(files.iter().any(|p| p.file_name().unwrap() == "test.rs"));

        // Sorted determinism: README.md before test.rs in most locales
        assert!(files.windows(2).all(|w| w[0] <= w[1]));

        // Done
        Ok(())
    }

    #[test]
    fn test_respects_gitignore() -> Result<()> {
        // Create temp directory
        let temp_dir = TempDir::new()?;
        let root = temp_dir.path();

        // Initialize git repo (required for gitignore to work with ignore crate)
        std::process::Command::new("git")
            .args(["init"])
            .current_dir(root)
            .output()
            .ok();

        // Create a .gitignore that ignores README.md
        write_file(root, ".gitignore", "README.md")?;

        // Create files — one ignored, one not
        write_file(root, "README.md", "# Ignored by gitignore")?;
        write_file(root, "keep.txt", "keep")?;

        // No extra ignores
        let walker = FileWalker::new(&[])?;

        // Walk files (should honor .gitignore)
        let files = walker.walk_files(root);

        // Filter out .git directory files and .gitignore itself for the test assertion
        let user_files: Vec<_> = files.iter()
            .filter(|f| {
                let path_str = f.to_string_lossy();
                !path_str.contains("/.git/") && 
                f.file_name().and_then(|n| n.to_str()) != Some(".gitignore")
            })
            .collect();

        // Only keep.txt should remain (README.md should be ignored by .gitignore)
        assert_eq!(user_files.len(), 1, "Expected 1 user file, found: {:?}", files);
        assert_eq!(user_files[0].file_name().unwrap(), "keep.txt");

        // Done
        Ok(())
    }

    #[test]
    fn test_additional_globs_prune_and_filter() -> Result<()> {
        // Create temp directory
        let temp_dir = TempDir::new()?;
        let root = temp_dir.path();

        // Create a heavy directory tree and a normal file
        write_file(root, "target/build/a.o", "bin")?;
        write_file(root, "node_modules/pkg/index.js", "js")?;
        write_file(root, "src/lib.rs", "pub fn x() {}")?;

        // Provide extra ignores that target directories
        let ignores = vec!["target/**".to_string(), "node_modules/**".to_string()];

        // Build walker with extra ignores
        let walker = FileWalker::new(&ignores)?;

        // Walk files
        let files = walker.walk_files(root);


        // Only src/lib.rs should remain (others pruned/filtered)
        assert_eq!(files.len(), 1, "unexpected files: {files:?}");
        assert_eq!(
            files[0].strip_prefix(root).unwrap(),
            Path::new("src/lib.rs")
        );

        // Done
        Ok(())
    }

    #[test]
    fn test_hidden_files_included_unless_ignored() -> Result<()> {
        // Create temp directory
        let temp_dir = TempDir::new()?;
        let root = temp_dir.path();

        // Create hidden and normal files
        write_file(root, ".hidden.txt", "h")?;
        write_file(root, "visible.txt", "v")?;

        // No .gitignore and no extra ignores → hidden should be included
        let walker = FileWalker::new(&[])?;
        let mut files = walker.walk_files(root);

        // Normalize relative paths for assertion clarity
        for p in &mut files {
            *p = p.strip_prefix(root).unwrap().to_path_buf();
        }

        // Expect both files
        assert!(files.contains(&PathBuf::from(".hidden.txt")));
        assert!(files.contains(&PathBuf::from("visible.txt")));

        // Done
        Ok(())
    }
}
```
